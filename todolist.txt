todo:
- 内存管理：将各种new出来的内存释放掉（也许就搁置了）
- 寄存器分配：先把所有指令都分配到栈上
  - （其实可以根据used_by来做一些事情，比如说，至少如果used_by的len为0，我们就可以不用给它分配空间，也不用实际加载到栈上，不过我们先不做这一点）
  - 寄存器作为指令的缓存，我们可以写一些函数实现这一点：每次使用一条指令，我们取出一个寄存器，将其加载至这个寄存器；可以采用LRU策略来置换（或者干脆随机去掉一个）
  - 每次块结束/出现函数调用，我们就将所有活跃寄存器中的指令都存回去
注意：
- toRaw()函数只对于产生koopa_raw_value的ast有有效返回值(例：exp)；toRaw()函数在调用过程中将语句/基本块生成于current_bbs中
- （其实也不仅限于koopa_raw_value,也可能是int等，视情况而定，但我们应该坚持toRaw()是返回这个ast所对应值的原则