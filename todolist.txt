todo:
- 内存管理：将各种new出来的内存释放掉（也许就搁置了）
- 寄存器分配：先把所有指令都分配到栈上
  - （其实可以根据used_by来做一些事情，比如说，至少如果used_by的len为0，我们就可以不用给它分配空间，也不用实际加载到栈上，不过我们先不做这一点）
  - 寄存器作为指令的缓存，我们可以写一些函数实现这一点：每次使用一条指令，我们取出一个寄存器，将其加载至这个寄存器；可以采用LRU策略来置换（或者干脆随机去掉一个）
  - 每次块结束/出现函数调用，我们就将所有活跃寄存器中的指令都存回去
    - 这一点其实是错误的，因为koopa是单赋值的，既然我们把它们都放在了栈上，那就不需要什么时候再存回去
    - 既然我们不做基本块之间的活跃分析，那么所有的具值的（并且有被使用的）指令在def的时候放在栈上就可以了
    - 之后其实只需要在需要的时候把它们加载到寄存器中。另外，既然我们不用a0-a7的寄存器，那么前八个参数或许根本就不需要再为它们分配栈空间
      （不过如果这里面又有再对函数的调用，就又出问题了，所以不做这个优化）
    - 我们需要做的只有两件事：
      - def：把指令放到栈上，并且为它分配一个寄存器
      - use：看指令是否已经分配了寄存器，若没有则分配一个
    - 当然，我们可以在基本块结束/出现函数调用时候让所有寄存器失效，不过仔细思考一下会发现这是不必要的
注意：
- toRaw()函数只对于产生koopa_raw_value的ast有有效返回值(例：exp)；toRaw()函数在调用过程中将语句/基本块生成于current_bbs中
- （其实也不仅限于koopa_raw_value,也可能是int等，视情况而定，但我们应该坚持toRaw()是返回这个ast所对应值的原则